package com.dinachi.passit.viewmodel


import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.dinachi.passit.datamodel.ChatMessage
import com.dinachi.passit.datamodel.Listing
import com.dinachi.passit.datamodel.User
import com.dinachi.passit.storage.RepositoryProvider
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

/**
 * ChatViewModel - Handles chat functionality
 * Merged version combining FirestoreDataSource approach with full features
 */
class ChatViewModel(
    application: Application
) : AndroidViewModel(application) {

    private val chatRepo = RepositoryProvider.provideChatRepo()
    private val listingRepo = RepositoryProvider.provideListingRepo()
    private val userRepo = RepositoryProvider.provideUserRepo()

    private val _uiState = MutableStateFlow(ChatUiState())
    val uiState: StateFlow<ChatUiState> = _uiState.asStateFlow()

    // Current message being typed
    private val _messageInput = MutableStateFlow("")
    val messageInput: StateFlow<String> = _messageInput.asStateFlow()

    /**
     * Initialize chat - loads listing, user, and starts observing messages
     */
    fun initializeChat(
        chatRoomId: String,
        listingId: String,
        otherUserId: String,
        currentUserId: String
    ) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }

            try {
                // Load listing info
                val listing = listingRepo.getListing(listingId)

                // Load other user info
                val otherUser = userRepo.getUser(otherUserId)

                _uiState.update {
                    it.copy(
                        chatRoomId = chatRoomId,
                        listing = listing,
                        otherUser = otherUser,
                        currentUserId = currentUserId,
                        isLoading = false
                    )
                }

                // Start observing messages
                observeMessages(chatRoomId)

            } catch (e: Exception) {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        error = e.message ?: "Failed to load chat"
                    )
                }
            }
        }
    }

    /**
     * Observe messages in real-time from Firestore
     */
    fun observeMessages(chatRoomId: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }

        chatRepo.observeMessages(chatRoomId)
                .catch { e ->
                    _uiState.update {
                        it.copy(isLoading = false, error = e.message)
                    }
                }
                .collectLatest { messages ->
                    // Sort by timestamp (oldest first for chat display)
                    val sortedMessages = messages.sortedBy { it.timestamp }

                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            messages = sortedMessages,
                            error = null
                        )
                    }
                }
        }
    }

    /**
     * Update message input text
     */
    fun onMessageInputChange(text: String) {
        _messageInput.value = text
    }

    /**
     * Send a text message
     */
    fun sendMessage() {
        val text = _messageInput.value.trim()
        if (text.isEmpty()) return

        val chatRoomId = _uiState.value.chatRoomId ?: return
        val otherUserId = _uiState.value.otherUser?.id ?: return

        viewModelScope.launch {
            _uiState.update { it.copy(isSending = true) }

            runCatching {
                val message = ChatMessage(
                    id = "", // Will be generated by Firestore
                    chatRoomId = chatRoomId,
                    senderId = _uiState.value.currentUserId ?: "",
                    messageText = text,
                    timestamp = System.currentTimeMillis(),
                    isRead = false,
                    imageUrl = null
                )
                chatRepo.sendMessage(message)
            }
                .onSuccess {
                    // Clear input after successful send
                    _messageInput.value = ""
                    _uiState.update { it.copy(isSending = false) }
                }
                .onFailure { e ->
                    _uiState.update {
                        it.copy(
                            isSending = false,
                            error = e.message ?: "Failed to send message"
                        )
                    }
                }
        }
    }

    /**
     * Send a text message with custom text (for direct calls)
     */
    fun sendMessageDirect(chatRoomId: String, receiverId: String, text: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isSending = true) }

            runCatching {
                val message = ChatMessage(
                    id = "", // Will be generated by Firestore
                    chatRoomId = chatRoomId,
                    senderId = _uiState.value.currentUserId ?: "",
                    messageText = text,
                    timestamp = System.currentTimeMillis(),
                    isRead = false,
                    imageUrl = null
                )
                chatRepo.sendMessage(message)
            }
                .onSuccess {
                    _uiState.update { it.copy(isSending = false) }
                }
                .onFailure { e ->
                    _uiState.update {
                        it.copy(
                            isSending = false,
                            error = e.message ?: "Send failed"
                        )
                    }
                }
        }
    }

    /**
     * Send an image message
     */
    fun sendImageMessage(imageUri: android.net.Uri) {
        val chatRoomId = _uiState.value.chatRoomId ?: return
        val otherUserId = _uiState.value.otherUser?.id ?: return

        viewModelScope.launch {
            _uiState.update { it.copy(isSending = true) }

            try {
                // TODO: Upload image first
                // val imageUrl = imageRepo.uploadImage(imageUri)
                // firestoreDs.sendMessage(chatRoomId, otherUserId, "", imageUrl)

                _uiState.update { it.copy(isSending = false) }

            } catch (e: Exception) {
                _uiState.update {
                    it.copy(
                        isSending = false,
                        error = "Failed to send image"
                    )
                }
            }
        }
    }

    /**
     * Mark messages as read
     */
    fun markMessagesAsRead() {
        val chatRoomId = _uiState.value.chatRoomId ?: return
        val currentUserId = _uiState.value.currentUserId ?: return

        viewModelScope.launch {
            try {
                // TODO: Implement in FirestoreDataSource if needed
                // firestoreDs.markMessagesAsRead(chatRoomId, currentUserId)
            } catch (e: Exception) {
                // Silent failure - not critical
                println("Failed to mark messages as read: ${e.message}")
            }
        }
    }

    /**
     * Clear error message
     */
    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }

    /**
     * Load just the other user (for simplified initialization)
     */
    fun loadOtherUser(userId: String) {
        viewModelScope.launch {
            try {
                val user = userRepo.getUser(userId)
                _uiState.update { it.copy(otherUser = user) }
            } catch (e: Exception) {
                _uiState.update { it.copy(error = "Failed to load user") }
            }
        }
    }

    /**
     * Load just the listing (for simplified initialization)
     */
    fun loadListing(listingId: String) {
        viewModelScope.launch {
            try {
                val listing = listingRepo.getListing(listingId)
                _uiState.update { it.copy(listing = listing) }
            } catch (e: Exception) {
                _uiState.update { it.copy(error = "Failed to load listing") }
            }
        }
    }
}

/**
 * UI State for ChatScreen
 */
data class ChatUiState(
    val isLoading: Boolean = true,
    val isSending: Boolean = false,
    val error: String? = null,
    val chatRoomId: String? = null,
    val listing: Listing? = null,
    val otherUser: User? = null,
    val currentUserId: String? = null,
    val messages: List<ChatMessage> = emptyList()
)